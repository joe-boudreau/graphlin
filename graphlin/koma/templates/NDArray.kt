/**
 * THIS FILE IS AUTOGENERATED, DO NOT MODIFY. EDIT THE FILES IN templates/
 * AND RUN ./gradlew :codegen INSTEAD!
 */

package koma.ndarray

import koma.extensions.fill
import koma.extensions.fillLinear
import koma.internal.*
import koma.internal.default.generated.ndarray.DefaultGenericNDArrayFactory
import koma.matrix.*
import koma.util.IndexIterator

// TODO: broadcasting, iteration by selected dims, views, reshape
/**
 * A general N-dimensional container for arbitrary types. For this container to be
 * useful, you'll probably want to import koma.extensions.*, which includes e.g.
 * element getter/setters which are non boxed for primitives.
 *
 * If you are looking for a 2D container supporting linear algebra, please look at
 * [Matrix].
 */
interface NDArray<T> {
    companion object {

        // TODO: Ideally these properties are expect/actual with implementations. However, there's currently
        // a generation issue with kotlin/native that breaks this approach, so as a workaround we'll define
        // getXFactory methods in koma.internal as expect actual and proxy them here. These properties have
        // to be lazily evaluated to avoid a race on startup in js, so we use private nullable fields and
        // initialize on first use

        $factories

        fun <T> createGeneric(vararg dims: Int, filler: (IntArray) -> T) =
            DefaultGenericNDArrayFactory<T>().createGeneric(*dims, filler = filler)

        fun <T> createGenericNulls(vararg dims: Int) =
                DefaultGenericNDArrayFactory<T?>().createGeneric(*dims, filler = {null})

        @Suppress("UNCHECKED_CAST")
        inline operator fun <reified T> invoke(vararg dims: Int,
                                               crossinline filler: (IntArray) -> T) =
            when(T::class) {
                $typeCheckClauses
                else          -> createGeneric(*dims) { filler(it) }
            } as NDArray<T>

        @Suppress("UNCHECKED_CAST")
        inline fun <reified T> createLinear(vararg dims: Int,
                                            crossinline filler: (Int) -> T) =
            when(T::class) {
                $typeCheckClausesLinear
                else          -> createGenericNulls<T>(*dims).fillLinear { filler(it) }
            } as NDArray<T>
    }

    val size: Int get() = shape().reduce { a, b -> a * b }
    fun shape(): List<Int>
    fun copy(): NDArray<T>

    fun getBaseArray(): Any

    fun toIterable(): Iterable<T> {
        return object: Iterable<T> {
            override fun iterator(): Iterator<T> = object: Iterator<T> {
                private var cursor = 0
                private val size = this@NDArray.size
                override fun next(): T {
                    cursor += 1
                    // TODO: Either make 1D access work like Matrix or fix this
                    // to not use the largest dimension.
                    return this@NDArray.getGeneric(cursor - 1)
                }
                override fun hasNext() = cursor < size
            }
        }
    }

    /**
     * Converts this NDArray into a one-dimensional List in row-major order.
     */
    fun toList() = List(size) { getGeneric(it) }

    /**
     * Converts this NDArray into a one-dimensional MutableList in row-major order.
     */
    fun toMutableList() = MutableList(size) { getGeneric(it) }

    /**
     * Find the linear index of the minimum element in this array.
     * If the array contains non-comparable values, this throws an exception.
     * This is intended for internal use.  Call argMin() instead.
     */
    fun argMinInternal(): Int

    /**
     * Find the linear index of the maximum element in this array.
     * If the array contains non-comparable values, this throws an exception.
     * This is intended for internal use.  Call argMax() instead.
     */
    fun argMaxInternal(): Int

    /**
     * Find the value of the minimum element in this array.
     * If the array contains non-comparable values, this throws an exception.
     * This is intended for internal use.  Call min() instead.
     */
    fun minInternal(): T

    /**
     * Find the value of the maximum element in this array.
     * If the array contains non-comparable values, this throws an exception.
     * This is intended for internal use.  Call max() instead.
     */
    fun maxInternal(): T

    // Iterator over the indices of this NDArray, simultaneously in array and linear form.
    // Not intended to be used directly, but instead used by ext funcs in `koma.extensions`
    fun iterateIndices() = IndexIterator { shape().toIntArray() }

    /**
     * Convert an N-dimensional index to a 1D index.  This is primarily for internal use.
     */
    fun nIdxToLinear(indices: IntArray): Int = throw NotImplementedError()

    /**
     * Convert a 1D index to an N-dimensional index.  This is primarily for internal use.
     */
    fun linearToNIdx(linear:Int): IntArray = throw NotImplementedError()

    // Primitive optimized getter/setters to avoid boxing. Not intended
    // to be used directly, but instead are used by ext funcs in `koma.extensions`.

    @KomaJsName("getGenericND")
    fun getGeneric(vararg indices: Int) = getGeneric(nIdxToLinear(indices))
    @KomaJsName("getGeneric1D")
    fun getGeneric(i: Int): T
    @KomaJsName("setGenericND")
    fun setGeneric(vararg indices: Int, v: T) = setGeneric(nIdxToLinear(indices), v)
    @KomaJsName("setGeneric1D")
    fun setGeneric(i: Int, v: T)

    $primitiveGetSet
}
