package koma

import koma.internal.KomaRandom
import koma.internal.getRng
import org.junit.Test

class RandomTests {

    @Test
    fun testReference() {
        // Compare to values generated by the reference implementation of PCG.
        
        val rng = KomaRandom(100, 1000)
        val expected = intArrayOf(1661439714, -1836977776, 1117698072, -1718436217, -1082162739,
                                  -227351909, -998247866, -997876715, 1616470541, 1410786046)
        for (i in 0 until 10)
            assert(rng.nextInt() == expected[i])
    }
    
    @Test
    fun testLongs() {
        // Compare to values previously generated for a particular seed and stream ID.

        val rng = KomaRandom(100, 1000)
        val expected = longArrayOf(3333302975963041506, 8685275004344070544, -8162949300458964968,
                                   -2084443369583231353, -6229690527369952819, -3250596073505103205,
                                   -77126618518130106, 6469229806394645525, -2164034534786899443, 8714269971029877502)
        for (i in 0 until 10)
            assert(rng.nextLong() == expected[i])
    }
    
    @Test
    fun testFloats() {
        // Compare to values previously generated for a particular seed and stream ID.

        val rng = KomaRandom(100, 1000)
        val expected = floatArrayOf(0.38683403f, 0.57229525f, 0.26023436f, 0.59989536f, 0.7480393f,
                                    0.9470655f, 0.7675773f, 0.7676637f, 0.37636387f, 0.32847416f)
        for (i in 0 until 10)
            assert(rng.nextFloat() == expected[i])
    }
    
    @Test
    fun testDouble() {
        // Compare to values previously generated for a particular seed and stream ID.

        val rng = KomaRandom(100, 1000)
        val expected = doubleArrayOf(0.18069871640457624, 0.4708297014171945, 0.5574856317276681,
                                     0.8870020985137427, 0.6622877998156564, 0.8237848337616458,
                                     0.9958189576323091, 0.35069765052005264, 0.8826874528025193, 0.4724015217107893)
        for (i in 0 until 10)
            assert(rng.nextDouble() == expected[i])
    }
    
    @Test
    fun testGaussian() {
        // Compare to values previously generated for a particular seed and stream ID.

        val rng = KomaRandom(100, 1000)
        val expected = doubleArrayOf(-1.327613921037247, -0.12128637267996473, 0.14553092648387286,
                                     0.9797365403362278, 0.5089036835226709, 1.0153276756308627,
                                     1.0265002688562428, -0.07402867581999663, -1.0995530663915685, -0.31456674010572827)
        for (i in 0 until 10)
            assert(rng.nextGaussian() == expected[i])
    }

    @Test
    fun testIntDistribution() {
        // Check that each bit is equally likely to be a 0 or 1.
        
        for (seed in 1L..20L) {
            val count = 10000
            val bitCounts = IntArray(32)
            val rng = KomaRandom(seed, 1)
            for (i in 1..count) {
                val value = rng.nextInt()
                for (j in 0 until 32)
                    if (value and (1 shl j) != 0)
                        bitCounts[j]++
            }
            val tol = 4*sqrt(count/2)
            for (i in 0 until 32) {
                assert(bitCounts[i] >= count/2 - tol)
                assert(bitCounts[i] <= count/2 + tol)
            }
        }
    }

    @Test
    fun testLongDistribution() {
        // Check that each bit is equally likely to be a 0 or 1.

        for (seed in 1L..20L) {
            val count = 10000
            val bitCounts = IntArray(64)
            val rng = KomaRandom(seed, 1)
            for (i in 1..count) {
                val value = rng.nextLong()
                for (j in 0 until 64) {
                    if (value and (1L shl j) != 0L)
                        bitCounts[j]++
                }
            }
            val tol = 4*sqrt(count/2)
            for (i in 0 until 64) {
                assert(bitCounts[i] >= count/2 - tol)
                assert(bitCounts[i] <= count/2 + tol)
            }
        }
    }
    
    @Test
    fun testBoundedIntDistribution() {
        // Check that each value occurs equally often.

        for (seed in 1L..20L) {
            val count = 10000
            val bins = 10
            val binCounts = IntArray(bins)
            val rng = KomaRandom(seed, 1)
            for (i in 1..count) {
                val value = rng.nextInt(bins)
                assert(value >= 0 && value < bins)
                binCounts[value]++
            }
            val tol = 4*sqrt(count/bins)
            for (i in 0 until bins) {
                assert(binCounts[i] >= count/bins - tol)
                assert(binCounts[i] <= count/bins + tol)
            }
        }
    }
    
    @Test
    fun testBoundedLongDistribution() {
        // Check that each value occurs equally often.

        for (seed in 1L..20L) {
            val count = 10000
            val bins = 10
            val binCounts = IntArray(bins)
            val rng = KomaRandom(seed, 1)
            for (i in 1..count) {
                val value = rng.nextLong(bins.toLong())
                assert(value >= 0 && value < bins)
                binCounts[value.toInt()]++
            }
            val tol = 4*sqrt(count/bins)
            for (i in 0 until bins) {
                assert(binCounts[i] >= count/bins - tol)
                assert(binCounts[i] <= count/bins + tol)
            }
        }
    }

    @Test
    fun testFloatDistribution() {
        // Check that values are uniformly distributed between 0 and 1.

        for (seed in 1L..20L) {
            val count = 10000
            val bins = 10
            val binCounts = IntArray(bins)
            val rng = KomaRandom(seed, 1)
            for (i in 1..count) {
                val value = rng.nextFloat()
                assert(value >= 0.0f && value < 1.0f)
                binCounts[(value*bins).toInt()]++
            }
            val tol = 4*sqrt(count/bins)
            for (i in 0 until bins) {
                assert(binCounts[i] >= count/bins - tol)
                assert(binCounts[i] <= count/bins + tol)
            }
        }
    }

    @Test
    fun testDoubleDistribution() {
        // Check that values are uniformly distributed between 0 and 1.

        for (seed in 1L..20L) {
            val count = 10000
            val bins = 10
            val binCounts = IntArray(bins)
            val rng = KomaRandom(seed, 1)
            for (i in 1..count) {
                val value = rng.nextDouble()
                assert(value >= 0.0 && value < 1.0)
                binCounts[(value*bins).toInt()]++
            }
            val tol = 4*sqrt(count/bins)
            for (i in 0 until bins) {
                assert(binCounts[i] >= count/bins - tol)
                assert(binCounts[i] <= count/bins + tol)
            }
        }
    }
    
    @Test
    fun testGaussianDistribution() {
        // Compute moments of the distribution.

        for (seed in 1L..20L) {
            val count = 10000
            val m = DoubleArray(4)
            val rng = KomaRandom(seed, 1)
            for (i in 1..count) {
                val value = rng.nextGaussian()
                m[0] += value
                m[1] += value*value
                m[2] += value*value*value
                m[3] += value*value*value*value
            }
            for (i in 0..3)
                m[i] = m[i]/count

            // Check the first few cumulants against their expected values.
            
            val c2 = m[1] - m[0]*m[0]
            val c3 = m[2] - 3*m[1]*m[0] + 2*m[0]*m[0]*m[0]
            val c4 = m[3] - 4*m[2]*m[0] - 3*m[1]*m[1] + 12*m[1]*m[0]*m[0] - 6*m[0]*m[0]*m[0]*m[0]
            val tol = 4.0/sqrt(count)
            assert(m[0] >= -tol && m[0] <= tol)
            assert(c2 >= 1.0-tol && c2 <= 1.0+tol)
            assert(c3 >= -5*tol && c3 <= 5*tol)
            assert(c4 >= -5*tol && c4 <= 5*tol)
        }
    }
    
    @Test
    fun testSeed() {
        val rng = KomaRandom(0, 1)
        val values = IntArray(10, { rng.nextInt() })
        
        // If we now set a different seed, we should get different values.
        
        rng.setSeed(1)
        for (i in 0 until values.size)
            assert(rng.nextInt() != values[i])
        
        // Now reset the original seed and verify that it produces the same values.

        rng.setSeed(0)
        for (i in 0 until values.size)
            assert(rng.nextInt() == values[i])
    }
}