@file:koma.internal.JvmName("MatrixExtensions")
@file:koma.internal.JvmMultifileClass

/**
 * THIS FILE IS AUTOGENERATED, DO NOT MODIFY. EDIT THE FILES IN templates/
 * AND RUN ./gradlew :codegen INSTEAD!
 */

package koma.extensions

import koma.matrix.Matrix
import koma.ndarray.NDArray
import koma.internal.KomaJsName
import koma.internal.KomaJvmName

/**
 * Checks to see if any element in the matrix causes f to return true.
 *
 * @param f A function which takes in an element from the matrix and returns a Boolean.
 *
 * @return Whether or not any element, when passed into f, causes f to return true.
 */
@KomaJsName("any${dtypeName}")
@KomaJvmName("any${dtypeName}")
${inline}fun ${genDec} Matrix<${dtype}>.any(f: (${dtype}) -> Boolean): Boolean {
    for (row in 0 until this.numRows())
        for (col in 0 until this.numCols())
            if (f(this[row, col]))
                return true
    return false
}

/**
 * Checks to see if all elements cause f to return true.
 *
 * @param f A function which takes in an element from the matrix and returns a Boolean.
 *
 * @return Returns true only if f is true for all elements of the input matrix
 */
@KomaJsName("all${dtypeName}")
@KomaJvmName("all${dtypeName}")
${inline}fun ${genDec} Matrix<${dtype}>.all(f: (${dtype}) -> Boolean): Boolean {
    for (row in 0 until this.numRows())
        for (col in 0 until this.numCols())
            if (!f(this[row, col]))
                return false
    return true
}

/**
 * Fills the matrix with the values returned by the input function.
 *
 * @param f A function which takes row,col and returns the value to fill. Note that
 * the return type must be the matrix primitive type (e.g. Double).
 */
@KomaJsName("fill${dtypeName}")
@KomaJvmName("fill${dtypeName}")
${inline}fun ${genDec} Matrix<${dtype}>.fill(f: (row: Int, col: Int) -> ${dtype}): Matrix<${dtype}> {
    for (row in 0 until this.numRows())
        for (col in 0 until this.numCols())
            this[row, col] = f(row, col)
    return this
}

/**
 * Passes each element in row major order into a function.
 *
 * @param f A function that takes in an element
 *
 */
@KomaJsName("forEach${dtypeName}")
@KomaJvmName("forEach${dtypeName}")
${inline}fun ${genDec} Matrix<${dtype}>.forEach(f: (${dtype}) -> Unit) {
    for (row in 0 until this.numRows())
        for (col in 0 until this.numCols())
            f(this[row, col])
}

/**
 * Returns a new Matrix with the given shape, populated with the data in this array.
 *
 * @param rows The number of rows in the desired matrix
 * @param cols The number of columns in the desired matrix
 *
 * @returns A copy of the elements in this array, shaped to the given number of rows and columns,
 *          such that `this.toList() == this.reshape(rows, cols).toList()`
 *
 * @throws IllegalArgumentException when `rows * cols` does not equal [size]
 */
@KomaJsName("reshape${dtypeName}")
@KomaJvmName("reshape${dtypeName}")
${reifiedInline}fun ${reifiedDec} ${reshapeReceiverType}<${dtype}>.reshape(rows: Int, cols: Int): Matrix<${dtype}> {
    if (rows * cols != size)
        throw IllegalArgumentException("\$size items cannot be reshaped to \$rows x \$cols")
    var idx = 0
    return ${factoryPattern("rows, cols")} { _, _ -> get${dtypeName}(idx++) }
}

/**
 * Passes each element in row major order into a function along with its index location.
 *
 * @param f A function that takes in a row,col position and an element value
 */
@KomaJsName("forEachIndexed${dtypeName}")
@KomaJvmName("forEachIndexed${dtypeName}")
${inline}fun ${genDec} Matrix<${dtype}>.forEachIndexed(f: (row: Int, col: Int, ele: ${dtype}) -> Unit) {
    for (row in 0 until this.numRows())
        for (col in 0 until this.numCols())
            f(row, col, this[row, col])
}


/**
 * Takes each element in a matrix, passes them through f, and puts the output of f into an
 * output matrix. This process is done in row-major order.
 *
 * @param f A function that takes in an element and returns an element
 *
 * @return the new matrix after each element is mapped through f
 */
@KomaJsName("map${dtypeName}")
@KomaJvmName("map${dtypeName}")
${inline}fun ${genDec} Matrix<${dtype}>.map(f: (${dtype}) -> ${dtype}): Matrix<${dtype}> {
    val out = this.getFactory().zeros(this.numRows(), this.numCols())
    for (row in 0 until this.numRows())
        for (col in 0 until this.numCols())
            out[row, col] = f(this[row, col])
    return out
}

/**
 * Takes each element in a matrix, passes them through f, and puts the output of f into an
 * output matrix. This process is done in row-major order.
 *
 * @param f A function that takes in an element and returns an element. Function also takes
 *      in the row, col index of the element's location.
 *
 * @return the new matrix after each element is mapped through f
 */
@KomaJsName("mapIndexed${dtypeName}")
@KomaJvmName("mapIndexed${dtypeName}")
${inline}fun ${genDec} Matrix<${dtype}>.mapIndexed(f: (row: Int, col: Int, ele: ${dtype}) -> ${dtype}): Matrix<${dtype}> {
    val out = this.getFactory().zeros(this.numRows(), this.numCols())
    for (row in 0 until this.numRows())
        for (col in 0 until this.numCols())
            out[row, col] = f(row, col, this[row, col])
    return out
}


@KomaJsName("get${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.get(i: Int, j: Int): ${dtype} = get${dtypeName}(i, j)
/**
 * Gets the ith element in the matrix. If 2D, selects elements in row-major order.
 */
@KomaJsName("get1D${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.get(i: Int): ${dtype} = get${dtypeName}(i)

/**
 * Allow slicing, e.g. ```matrix[1..2, 3..4]```. Note that the range 1..2 is inclusive, so
 * it will retrieve row 1 and 2. Use 1.until(2) for a non-inclusive range.
 *
 * @param rows the set of rows to select
 * @param cols the set of columns to select
 *
 * @return a new matrix containing the submatrix.
 */
@KomaJvmName("getRanges${dtypeName}")
@KomaJsName("getRanges${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.get(rows: IntRange, cols: IntRange): Matrix<${dtype}>
{
    val wrows = wrapRange(rows, numRows())
    val wcols = wrapRange(cols, numCols())

    val out = this.getFactory().zeros(wrows.endInclusive - wrows.start + 1,
            wcols.endInclusive - wcols.start + 1)
    for (row in wrows)
        for (col in wcols)
            out[row - wrows.start, col - wcols.start] = this[row, col]
    return out
}
/**
 * Allows for slicing of the rows and selection of a single column
 */
@KomaJvmName("setRowRange${dtypeName}")
@KomaJsName("getRowRange${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.get(rows: IntRange, cols: Int) = this[rows, cols..cols]

/**
 * Allows for slicing of the cols and selection of a single row
 */
@KomaJvmName("getColRange${dtypeName}")
@KomaJsName("getColRange${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.get(rows: Int, cols: IntRange) = this[rows..rows, cols]


/**
 * Set the ith element in the matrix. If 2D, selects elements in row-major order.
 */
@KomaJvmName("set1D${dtypeName}")
@KomaJsName("set1D${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.set(i: Int, v: ${dtype}) = set${dtypeName}(i, v)
@KomaJvmName("set2D${dtypeName}")
@KomaJsName("set2D${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.set(i: Int, j: Int, v: ${dtype}) = set${dtypeName}(i, j, v)
/**
 * Allow assignment to a slice, e.g. ```matrix[1..2, 3..4]```=something. Note that the range 1..2 is inclusive, so
 * it will retrieve row 1 and 2. Use 1.until(2) for a non-inclusive range.
 *
 * @param rows the set of rows to select
 * @param cols the set of columns to select
 * @param value the matrix to set the subslice to
 *
 */
@KomaJvmName("setRanges${dtypeName}")
@KomaJsName("setRanges${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.set(rows: IntRange, cols: IntRange, value: Matrix<${dtype}>)
{
    val wrows = wrapRange(rows, numRows())
    val wcols = wrapRange(cols, numCols())

    for (i in wrows)
        for (j in wcols)
            this[i, j] = value[i - wrows.start, j - wcols.start]
}
@KomaJsName("setRangesScalar${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.set(rows: IntRange, cols: IntRange, value: ${dtype})
{
    val wrows = wrapRange(rows, numRows())
    val wcols = wrapRange(cols, numCols())

    for (i in wrows)
        for (j in wcols)
            this[i, j] = value
}
/**
 * Allow assignment to a slice, e.g. ```matrix[2, 3..4]```=something. Note that the range 3..4 is inclusive, so
 * it will retrieve col 3 and 4. Use 1.until(2) for a non-inclusive range.
 *
 * @param rows the row to select
 * @param cols the set of columns to select
 * @param value the matrix to set the subslice to
 *
 */
@KomaJvmName("setColRange${dtypeName}")
@KomaJsName("setColRange${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.set(rows: Int, cols: IntRange, value: Matrix<${dtype}>)
{
    this[rows..rows, cols] = value
}
@KomaJvmName("setColRangeScalar${dtypeName}")
@KomaJsName("setColRangeScalar${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.set(rows: Int, cols: IntRange, value: ${dtype})
{
    this[rows..rows, cols] = value
}
/**
 * Allow assignment to a slice, e.g. ```matrix[1..2, 3]```=something. Note that the range 1..2 is inclusive, so
 * it will retrieve row 1 and 2. Use 1.until(2) for a non-inclusive range.
 *
 * @param rows the set of rows to select
 * @param cols the column to select
 * @param value the matrix to set the subslice to
 *
 */
@KomaJvmName("setRowRange${dtypeName}")
@KomaJsName("setRowRange${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.set(rows: IntRange, cols: Int, value: Matrix<${dtype}>) {
    this[rows, cols..cols] = value
}
@KomaJsName("setRowRangeScalar${dtypeName}")
operator fun ${genDec} Matrix<${dtype}>.set(rows: IntRange, cols: Int, value: ${dtype}) {
    this[rows, cols..cols] = value
}

${floatersOnly}