/**
 * THIS FILE IS AUTOGENERATED, DO NOT MODIFY. EDIT THE FILES IN templates/
 * AND RUN ./gradlew :codegen INSTEAD!
 */

package koma.internal.default.generated.matrix

import koma.*
import koma.extensions.*
import koma.matrix.*
import koma.internal.notImplemented
import koma.internal.default.utils.*


class DefaultFloatMatrix (val rows: Int, 
                          val cols: Int): Matrix<Float> {
    val storage = FloatArray(rows*cols)

    
    override fun div(other: Float): Matrix<Float>
            = this.mapIndexed { _, _, ele -> ele/other}

    
    override fun div(other: Int): Matrix<Float>
            = this.mapIndexed { _, _, ele -> ele/other}


    override fun times(other: Matrix<Float>): Matrix<Float> {
        val out = getFactory().zeros(this.numRows(), other.numCols())
        out.forEachIndexed { row, col, _ ->
            for (cursor in 0 until this.numCols())
                out[row,col] += this[row, cursor]*other[cursor, col]
        }
        return out
    }
    
    override fun times(other: Float): Matrix<Float> 
            = this.map { it*other }

    override fun unaryMinus(): Matrix<Float> 
            = this.map { it*-1 }

    override fun minus(other: Float): Matrix<Float>
            = this.map { it - other }
    
    override fun minus(other: Matrix<Float>): Matrix<Float> 
            = this.mapIndexed { row, col, ele -> ele - other[row,col] }

    override fun plus(other: Float): Matrix<Float> 
            = this.map { it + other }

    override fun plus(other: Matrix<Float>): Matrix<Float> 
            = this.mapIndexed { row, col, ele -> ele + other[row,col] }

    override fun transpose(): Matrix<Float> 
            = getFactory()
            .zeros(numCols(),numRows())
            .fill { row, col -> this[col,row] }

    override fun elementTimes(other: Matrix<Float>): Matrix<Float> 
            = this.mapIndexed { row, col, ele -> ele*other[row,col] }

    
    override fun epow(other: Float): Matrix<Float> 
            = this.mapIndexed { _, _, ele -> pow(ele.toDouble(), other.toDouble()).toFloat() }

    
    override fun epow(other: Int): Matrix<Float>
            = this.mapIndexed { _, _, ele -> pow(ele.toDouble(), other.toDouble()).toFloat() }

    override fun numRows(): Int = this.rows
    override fun numCols(): Int = this.cols

    private fun setStorage(i: Int, v: Float) {
        storage[i] = v
    }
    private fun setStorage(i: Int, j: Int, v: Float) {
        storage[this.cols*wrapIndex(i,rows) + wrapIndex(j,cols)] = v
    }

    private fun getStorage(i: Int, j: Int): Float {
        return storage[this.cols*wrapIndex(i,rows) + wrapIndex(j,cols)]
    }

    private fun getStorage(i: Int): Float 
            = storage[i]
    
    override fun copy(): Matrix<Float> 
            = this.map { it }
    
    
    override fun getInt(i: Int, j: Int): Int = this.getStorage(i,j).toInt()
    override fun getDouble(i: Int, j: Int): Double = this.getStorage(i,j).toDouble()
    override fun getFloat(i: Int, j: Int): Float = this.getStorage(i,j).toFloat()
    override fun getGeneric(i: Int, j: Int): Float = this.getStorage(i,j)
    override fun getInt(i: Int): Int = this.getStorage(i).toInt()
    override fun getDouble(i: Int): Double = this.getStorage(i).toDouble()
    override fun getFloat(i: Int): Float = this.getStorage(i).toFloat()
    override fun getGeneric(i: Int): Float = this.getStorage(i)
    override fun setInt(i: Int, v: Int) { this.setStorage(i, v.toFloat())}
    override fun setDouble(i: Int, v: Double) { this.setStorage(i, v.toFloat())}
    override fun setFloat(i: Int, v: Float) { this.setStorage(i, v.toFloat())}
    override fun setGeneric(i: Int, v: Float) { this.setStorage(i, v)}
    override fun setInt(i: Int, j: Int, v: Int) { this.setStorage(i, j, v.toFloat())}
    override fun setDouble(i: Int, j: Int, v: Double) { this.setStorage(i, j, v.toFloat())}
    override fun setFloat(i: Int, j: Int, v: Float) { this.setStorage(i, j, v.toFloat())}
    override fun setGeneric(i: Int, j: Int, v: Float) { this.setStorage(i, j, v)}
    override fun getDoubleData(): DoubleArray = storage.map { it.toDouble() }.toDoubleArray()
    override fun getRow(row: Int): Matrix<Float> {
        val out = getFactory().zeros(1,cols)
        for (i in 0 until cols)
            out[i] = this[row, i]
        return out
    }
    override fun getCol(col: Int): Matrix<Float> {
        val out = getFactory().zeros(rows,1)
        for (i in 0 until rows)
            out[i] = this[i, col]
        return out
    }

    override fun setCol(index: Int, col: Matrix<Float>) {
        for (i in 0 until rows)
            this[i, index] = col[i]
    }

    override fun setRow(index: Int, row: Matrix<Float>) {
        for (i in 0 until cols)
            this[index, i] = row[i]
    }

    override fun chol(): Matrix<Float> {
        error(notImplemented)
    }

    override fun LU(): Triple<Matrix<Float>, Matrix<Float>, Matrix<Float>> {
        error(notImplemented)
    }

    override fun QR(): Pair<Matrix<Float>, Matrix<Float>> {
        error(notImplemented)
    }

    override fun SVD(): Triple<Matrix<Float>, Matrix<Float>, Matrix<Float>> {
        error(notImplemented)
    }

	override fun expm(): Matrix<Float> {
        error(notImplemented)
    }

    override fun solve(other: Matrix<Float>): Matrix<Float> {
        error(notImplemented)
    }

    override fun inv(): Matrix<Float> {
        error(notImplemented)
    }

    override fun det(): Float {
        error(notImplemented)
    }

    override fun pinv(): Matrix<Float> {
        error(notImplemented)
    }

    override fun normF(): Float {
        error(notImplemented)
    }

    override fun normIndP1(): Float {
        error(notImplemented)
    }

    override fun elementSum(): Float 
            = this.toIterable().reduce { a, b -> a + b }

    override fun diag(): Matrix<Float> 
            = getFactory()
            .zeros(numRows(),1)
            .fill{ row, _ -> this[row,row] }

    override fun maxInternal(): Float = this[argMax()]
    override fun mean(): Float = elementSum()/(numRows()*numCols())
    override fun minInternal(): Float = this[argMin()]

    override fun argMaxInternal(): Int {
        var highest= Float.MIN_VALUE
        var highestIdx = -1
        for (i in 0 until numRows()*numCols())
            if(this[i] > highest) {
                highest = this[i]
                highestIdx = i
            }
        return highestIdx
    }

    override fun argMinInternal(): Int {
        var lowest = Float.MAX_VALUE
        var lowestIdx = -1
        for (i in 0 until numRows()*numCols())
            if(this[i] < lowest) {
                lowest = this[i]
                lowestIdx = i
            }
        return lowestIdx
    }

    override fun trace(): Float {
        error(notImplemented)
    }

    override fun T(): Matrix<Float> = this.transpose()

    override fun getBaseMatrix(): Any 
            = storage
    override fun getFactory(): MatrixFactory<Matrix<Float>> 
            = DefaultFloatMatrixFactory()
}
