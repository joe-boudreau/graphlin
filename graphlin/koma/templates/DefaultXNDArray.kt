/**
 * THIS FILE IS AUTOGENERATED, DO NOT MODIFY. EDIT THE FILES IN templates/
 * AND RUN ./gradlew :codegen INSTEAD!
 */

package ${namespace}.ndarray

import koma.ndarray.*
import koma.internal.KomaJsName
import koma.internal.default.utils.*


/**
 * An (unoptimized) implementation of [NDArray] in pure Kotlin, for portability between the
 * different platforms koma supports.
 *
 * @param shape A vararg specifying the size of each dimension, e.g. a 3D array with size 4x6x8 would pass in 4,6,8)
 * @param init A function that takes a location in the new array and returns its initial value.
 */
open class Default${dtypeName}NDArray${genDec}(@KomaJsName("shape_private") vararg protected val shape: Int,
                             init: ((IntArray)->${dtype})): NDArray<${dtype}> {

    /**
     * Underlying storage. Default backends uses a simple array.
     */
    private val storage: ${storage}
    private val shapeAsList: List<Int> = shape.toList()
    private val widthOfDims: IntArray = widthOfDims(shapeAsList)

    init {
${initStorage}
    }

    override fun getGeneric(vararg indices: Int): ${dtype} {
        checkIndices(indices)
        return storage[nIdxToLinear(indices)]
    }
    override fun getGeneric(i: Int): ${dtype} = storage[i]
    override fun setGeneric(i: Int, v: ${dtype}) { storage[i] = v }

    override fun setGeneric(vararg indices: Int, v: ${dtype}) {
        checkIndices(indices)
        storage[nIdxToLinear(indices)] = v
    }
    // TODO: cache this
    override val size get() = storage.size
    override fun shape(): List<Int> = shapeAsList
    override fun copy(): NDArray<${dtype}> = Default${dtypeName}NDArray(*shape, init = { this.getGeneric(*it) })
    override fun getBaseArray(): Any = storage

    override fun nIdxToLinear(indices: IntArray): Int {
        if (indices.size != shape.size)
            throw IllegalArgumentException("Cannot index an array with shape \${shapeAsList} with " +
                    "anything other than \${shape.size} indices (\${indices.size} given)")
        var out = 0
        indices.forEachIndexed { i, idxArr ->
            out += wrapIndex(idxArr, shape[i]) * widthOfDims[i]
        }
        return out
    }

    override fun linearToNIdx(linear:Int): IntArray {
        var remaining = linear
        val out = kotlin.IntArray(shape.size, { it })
        out.map { idx ->
            out[idx] = remaining / widthOfDims[idx]
            remaining -= out[idx] * widthOfDims[idx]
        }
        return out
    }
    private val wrongType = "Double methods not implemented for generic NDArray"
${getDouble}
${setDouble}
${getByte}
${setByte}
${getInt}
${setInt}
${getFloat}
${setFloat}
${getLong}
${setLong}
${getShort}
${setShort}

    override fun toString(): String {
        if (size == 0)
            return "[]"
        val s = StringBuilder()
        val index = IntArray(shape.size)
        val lastAxis = shape.size-1
        val width = shape[lastAxis]
        var printBracketsFrom = 0
        while (index[0] < shape[0]) {
            for (i in 0..lastAxis)
                s.append(if (i >= printBracketsFrom) '[' else ' ')
            for (i in 0 until width) {
                index[lastAxis] = i
                s.append(get${dtypeName}(*index))
                if (i < width-1)
                    s.append(", ")
            }
            for (i in lastAxis downTo 0) {
                index[i] += 1
                if (index[i] == shape[i]) {
                    s.append(']')
                    printBracketsFrom = i
                    if (i > 0)
                        index[i] = 0
                    else
                        break
                }
                else
                    break
            }
            if (index[0] < shape[0])
                s.append('\\n')
        }
        return s.toString()
    }

    override fun argMinInternal() =
            argMin${dtypeName}(size, { get${dtypeName}(it) })

    override fun argMaxInternal() =
            argMax${dtypeName}(size, { get${dtypeName}(it) })

    override fun minInternal() =
            get${dtypeName}(argMin${dtypeName}(size, { get${dtypeName}(it) }))

    override fun maxInternal() =
            get${dtypeName}(argMax${dtypeName}(size, { get${dtypeName}(it) }))

}

